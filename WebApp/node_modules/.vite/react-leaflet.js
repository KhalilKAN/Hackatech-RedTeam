import {
  require_react_dom
} from "./chunk-YRQM33ZV.js";
import {
  require_react
} from "./chunk-UGX4TM2U.js";
import {
  require_leaflet_src
} from "./chunk-ABEWA47W.js";
import {
  __objRest,
  __restKey,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-IPTOCG2Y.js";

// node_modules/@react-leaflet/core/esm/attribution.js
var import_react = __toESM(require_react());
function useAttribution(map, attribution) {
  const attributionRef = (0, import_react.useRef)(attribution);
  (0, import_react.useEffect)(function updateAttribution() {
    if (attribution !== attributionRef.current && map.attributionControl != null) {
      if (attributionRef.current != null) {
        map.attributionControl.removeAttribution(attributionRef.current);
      }
      if (attribution != null) {
        map.attributionControl.addAttribution(attribution);
      }
    }
    attributionRef.current = attribution;
  }, [map, attribution]);
}

// node_modules/@react-leaflet/core/esm/circle.js
function updateCircle(layer, props, prevProps) {
  if (props.center !== prevProps.center) {
    layer.setLatLng(props.center);
  }
  if (props.radius != null && props.radius !== prevProps.radius) {
    layer.setRadius(props.radius);
  }
}

// node_modules/@react-leaflet/core/esm/component.js
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@react-leaflet/core/esm/context.js
var import_react2 = __toESM(require_react());
var CONTEXT_VERSION = 1;
var LeafletContext = (0, import_react2.createContext)(null);
var LeafletProvider = LeafletContext.Provider;
function useLeafletContext() {
  const context = (0, import_react2.useContext)(LeafletContext);
  if (context == null) {
    throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
  }
  return context;
}

// node_modules/@react-leaflet/core/esm/component.js
function createContainerComponent(useElement) {
  function ContainerComponent(props, ref) {
    const {
      instance,
      context
    } = useElement(props).current;
    (0, import_react3.useImperativeHandle)(ref, () => instance);
    return props.children == null ? null : import_react3.default.createElement(LeafletProvider, {
      value: context
    }, props.children);
  }
  return (0, import_react3.forwardRef)(ContainerComponent);
}
function createDivOverlayComponent(useElement) {
  function OverlayComponent(props, ref) {
    const [isOpen, setOpen] = (0, import_react3.useState)(false);
    const {
      instance
    } = useElement(props, setOpen).current;
    (0, import_react3.useImperativeHandle)(ref, () => instance);
    (0, import_react3.useEffect)(function updateOverlay() {
      if (isOpen) {
        instance.update();
      }
    }, [instance, isOpen, props.children]);
    const contentNode = instance._contentNode;
    return contentNode ? (0, import_react_dom.createPortal)(props.children, contentNode) : null;
  }
  return (0, import_react3.forwardRef)(OverlayComponent);
}
function createLeafComponent(useElement) {
  function LeafComponent(props, ref) {
    const {
      instance
    } = useElement(props).current;
    (0, import_react3.useImperativeHandle)(ref, () => instance);
    return null;
  }
  return (0, import_react3.forwardRef)(LeafComponent);
}

// node_modules/@react-leaflet/core/esm/control.js
var import_react4 = __toESM(require_react());
function createControlHook(useElement) {
  return function useLeafletControl(props) {
    const context = useLeafletContext();
    const elementRef = useElement(props, context);
    const {
      instance
    } = elementRef.current;
    const positionRef = (0, import_react4.useRef)(props.position);
    const {
      position
    } = props;
    (0, import_react4.useEffect)(function addControl() {
      instance.addTo(context.map);
      return function removeControl() {
        instance.remove();
      };
    }, [context.map, instance]);
    (0, import_react4.useEffect)(function updateControl() {
      if (position != null && position !== positionRef.current) {
        instance.setPosition(position);
        positionRef.current = position;
      }
    }, [instance, position]);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/esm/events.js
var import_react5 = __toESM(require_react());
function useEventHandlers(element, eventHandlers) {
  const eventHandlersRef = (0, import_react5.useRef)();
  (0, import_react5.useEffect)(function addEventHandlers() {
    if (eventHandlers != null) {
      element.instance.on(eventHandlers);
    }
    eventHandlersRef.current = eventHandlers;
    return function removeEventHandlers() {
      if (eventHandlersRef.current != null) {
        element.instance.off(eventHandlersRef.current);
      }
      eventHandlersRef.current = null;
    };
  }, [element, eventHandlers]);
}

// node_modules/@react-leaflet/core/esm/pane.js
function withPane(props, context) {
  var _a;
  const pane = (_a = props.pane) != null ? _a : context.pane;
  return pane ? __spreadProps(__spreadValues({}, props), {
    pane
  }) : props;
}

// node_modules/@react-leaflet/core/esm/div-overlay.js
function createDivOverlayHook(useElement, useLifecycle) {
  return function useDivOverlay(props, setOpen) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLifecycle(elementRef.current, context, props, setOpen);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/esm/dom.js
var import_leaflet = __toESM(require_leaflet_src());
function splitClassName(className) {
  return className.split(" ").filter(Boolean);
}
function addClassName(element, className) {
  splitClassName(className).forEach((cls) => {
    import_leaflet.DomUtil.addClass(element, cls);
  });
}

// node_modules/@react-leaflet/core/esm/element.js
var import_react6 = __toESM(require_react());
function createElementHook(createElement, updateElement) {
  if (updateElement == null) {
    return function useImmutableLeafletElement(props, context) {
      return (0, import_react6.useRef)(createElement(props, context));
    };
  }
  return function useMutableLeafletElement(props, context) {
    const elementRef = (0, import_react6.useRef)(createElement(props, context));
    const propsRef = (0, import_react6.useRef)(props);
    const {
      instance
    } = elementRef.current;
    (0, import_react6.useEffect)(function updateElementProps() {
      if (propsRef.current !== props) {
        updateElement(instance, props, propsRef.current);
        propsRef.current = props;
      }
    }, [instance, props, context]);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/esm/layer.js
var import_react7 = __toESM(require_react());
function useLayerLifecycle(element, context) {
  (0, import_react7.useEffect)(function addLayer() {
    var _a;
    const container = (_a = context.layerContainer) != null ? _a : context.map;
    container.addLayer(element.instance);
    return function removeLayer() {
      var _context$layerContain;
      (_context$layerContain = context.layerContainer) == null ? void 0 : _context$layerContain.removeLayer(element.instance);
      context.map.removeLayer(element.instance);
    };
  }, [context, element]);
}
function createLayerHook(useElement) {
  return function useLayer(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/esm/path.js
var import_react8 = __toESM(require_react());
function usePathOptions(element, props) {
  const optionsRef = (0, import_react8.useRef)();
  (0, import_react8.useEffect)(function updatePathOptions() {
    var _a;
    if (props.pathOptions !== optionsRef.current) {
      const options = (_a = props.pathOptions) != null ? _a : {};
      element.instance.setStyle(options);
      optionsRef.current = options;
    }
  }, [element, props]);
}
function createPathHook(useElement) {
  return function usePath(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    usePathOptions(elementRef.current, props);
    return elementRef;
  };
}

// node_modules/@react-leaflet/core/esm/generic.js
function createControlComponent(createInstance) {
  function createElement(props, context) {
    return {
      instance: createInstance(props),
      context
    };
  }
  const useElement = createElementHook(createElement);
  const useControl = createControlHook(useElement);
  return createLeafComponent(useControl);
}
function createLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createContainerComponent(useLayer);
}
function createOverlayComponent(createElement, useLifecycle) {
  const useElement = createElementHook(createElement);
  const useOverlay = createDivOverlayHook(useElement, useLifecycle);
  return createDivOverlayComponent(useOverlay);
}
function createPathComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const usePath = createPathHook(useElement);
  return createContainerComponent(usePath);
}
function createTileLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createLeafComponent(useLayer);
}

// node_modules/@react-leaflet/core/esm/grid-layer.js
function updateGridLayer(layer, props, prevProps) {
  const {
    opacity,
    zIndex
  } = props;
  if (opacity != null && opacity !== prevProps.opacity) {
    layer.setOpacity(opacity);
  }
  if (zIndex != null && zIndex !== prevProps.zIndex) {
    layer.setZIndex(zIndex);
  }
}

// node_modules/@react-leaflet/core/esm/media-overlay.js
var import_leaflet2 = __toESM(require_leaflet_src());
function updateMediaOverlay(overlay, props, prevProps) {
  if (props.bounds instanceof import_leaflet2.LatLngBounds && props.bounds !== prevProps.bounds) {
    overlay.setBounds(props.bounds);
  }
  if (props.opacity != null && props.opacity !== prevProps.opacity) {
    overlay.setOpacity(props.opacity);
  }
  if (props.zIndex != null && props.zIndex !== prevProps.zIndex) {
    overlay.setZIndex(props.zIndex);
  }
}

// node_modules/react-leaflet/esm/hooks.js
var import_react9 = __toESM(require_react());
function useMap() {
  return useLeafletContext().map;
}
function useMapEvent(type, handler) {
  const map = useMap();
  (0, import_react9.useEffect)(function addMapEventHandler() {
    map.on(type, handler);
    return function removeMapEventHandler() {
      map.off(type, handler);
    };
  }, [map, type, handler]);
  return map;
}
function useMapEvents(handlers) {
  const map = useMap();
  (0, import_react9.useEffect)(function addMapEventHandlers() {
    map.on(handlers);
    return function removeMapEventHandlers() {
      map.off(handlers);
    };
  }, [map, handlers]);
  return map;
}

// node_modules/react-leaflet/esm/AttributionControl.js
var import_leaflet3 = __toESM(require_leaflet_src());
var AttributionControl = createControlComponent(function createAttributionControl(props) {
  return new import_leaflet3.Control.Attribution(props);
});

// node_modules/react-leaflet/esm/Circle.js
var import_leaflet4 = __toESM(require_leaflet_src());
var Circle = createPathComponent(function createCircle(_ref, ctx) {
  let _a = _ref, {
    center,
    children: _c
  } = _a, options = __objRest(_a, [
    "center",
    "children"
  ]);
  const instance = new import_leaflet4.Circle(center, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, updateCircle);

// node_modules/react-leaflet/esm/CircleMarker.js
var import_leaflet5 = __toESM(require_leaflet_src());
var CircleMarker = createPathComponent(function createCircleMarker(_ref, ctx) {
  let _a = _ref, {
    center,
    children: _c
  } = _a, options = __objRest(_a, [
    "center",
    "children"
  ]);
  const instance = new import_leaflet5.CircleMarker(center, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, updateCircle);

// node_modules/react-leaflet/esm/FeatureGroup.js
var import_leaflet6 = __toESM(require_leaflet_src());
var FeatureGroup = createPathComponent(function createFeatureGroup(_ref, ctx) {
  let _a = _ref, {
    children: _c
  } = _a, options = __objRest(_a, [
    "children"
  ]);
  const instance = new import_leaflet6.FeatureGroup([], options);
  const context = __spreadProps(__spreadValues({}, ctx), {
    layerContainer: instance,
    overlayContainer: instance
  });
  return {
    instance,
    context
  };
});

// node_modules/react-leaflet/esm/GeoJSON.js
var import_leaflet7 = __toESM(require_leaflet_src());
var GeoJSON = createPathComponent(function createGeoJSON(_ref, ctx) {
  let _a = _ref, {
    data
  } = _a, options = __objRest(_a, [
    "data"
  ]);
  const instance = new import_leaflet7.GeoJSON(data, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updateGeoJSON(layer, props, prevProps) {
  if (props.style !== prevProps.style) {
    if (props.style == null) {
      layer.resetStyle();
    } else {
      layer.setStyle(props.style);
    }
  }
});

// node_modules/react-leaflet/esm/ImageOverlay.js
var import_leaflet8 = __toESM(require_leaflet_src());
var ImageOverlay = createLayerComponent(function createImageOveraly(_ref, ctx) {
  let _a = _ref, {
    bounds,
    url
  } = _a, options = __objRest(_a, [
    "bounds",
    "url"
  ]);
  const instance = new import_leaflet8.ImageOverlay(url, bounds, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updateImageOverlay(overlay, props, prevProps) {
  updateMediaOverlay(overlay, props, prevProps);
  if (props.url !== prevProps.url) {
    overlay.setUrl(props.url);
  }
});

// node_modules/react-leaflet/esm/LayerGroup.js
var import_leaflet9 = __toESM(require_leaflet_src());
var LayerGroup = createLayerComponent(function createLayerGroup(_ref, ctx) {
  let _a = _ref, {
    children: _c
  } = _a, options = __objRest(_a, [
    "children"
  ]);
  const instance = new import_leaflet9.LayerGroup([], options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      layerContainer: instance
    })
  };
});

// node_modules/react-leaflet/esm/LayersControl.js
var import_leaflet10 = __toESM(require_leaflet_src());
var import_react10 = __toESM(require_react());
var useLayersControlElement = createElementHook(function createLayersControl(_ref, ctx) {
  let _a = _ref, {
    children: _c
  } = _a, options = __objRest(_a, [
    "children"
  ]);
  const instance = new import_leaflet10.Control.Layers(void 0, void 0, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      layersControl: instance
    })
  };
}, function updateLayersControl(control, props, prevProps) {
  if (props.collapsed !== prevProps.collapsed) {
    if (props.collapsed === true) {
      control.collapse();
    } else {
      control.expand();
    }
  }
});
var useLayersControl = createControlHook(useLayersControlElement);
var LayersControl = createContainerComponent(useLayersControl);
function createControlledLayer(addLayerToControl) {
  return function ControlledLayer(props) {
    const parentContext = useLeafletContext();
    const propsRef = (0, import_react10.useRef)(props);
    const [layer, setLayer] = (0, import_react10.useState)(null);
    const {
      layersControl,
      map
    } = parentContext;
    const addLayer = (0, import_react10.useCallback)((layerToAdd) => {
      if (layersControl != null) {
        if (propsRef.current.checked) {
          map.addLayer(layerToAdd);
        }
        addLayerToControl(layersControl, layerToAdd, propsRef.current.name);
        setLayer(layerToAdd);
      }
    }, [layersControl, map]);
    const removeLayer = (0, import_react10.useCallback)((layerToRemove) => {
      layersControl == null ? void 0 : layersControl.removeLayer(layerToRemove);
      setLayer(null);
    }, [layersControl]);
    const context = (0, import_react10.useMemo)(() => __spreadProps(__spreadValues({}, parentContext), {
      layerContainer: {
        addLayer,
        removeLayer
      }
    }), [parentContext, addLayer, removeLayer]);
    (0, import_react10.useEffect)(() => {
      if (layer !== null && propsRef.current !== props) {
        if (props.checked === true && (propsRef.current.checked == null || propsRef.current.checked === false)) {
          map.addLayer(layer);
        } else if (propsRef.current.checked === true && (props.checked == null || props.checked === false)) {
          map.removeLayer(layer);
        }
        propsRef.current = props;
      }
    });
    return props.children ? import_react10.default.createElement(LeafletProvider, {
      value: context
    }, props.children) : null;
  };
}
LayersControl.BaseLayer = createControlledLayer(function addBaseLayer(layersControl, layer, name) {
  layersControl.addBaseLayer(layer, name);
});
LayersControl.Overlay = createControlledLayer(function addOverlay(layersControl, layer, name) {
  layersControl.addOverlay(layer, name);
});

// node_modules/react-leaflet/esm/MapConsumer.js
function MapConsumer(_ref) {
  let {
    children
  } = _ref;
  return children(useMap());
}

// node_modules/react-leaflet/esm/MapContainer.js
var import_leaflet11 = __toESM(require_leaflet_src());
var import_react11 = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function useMapElement(mapRef, props) {
  const [map, setMap] = (0, import_react11.useState)(null);
  (0, import_react11.useEffect)(() => {
    if (mapRef.current !== null && map === null) {
      const instance = new import_leaflet11.Map(mapRef.current, props);
      if (props.center != null && props.zoom != null) {
        instance.setView(props.center, props.zoom);
      } else if (props.bounds != null) {
        instance.fitBounds(props.bounds, props.boundsOptions);
      }
      if (props.whenReady != null) {
        instance.whenReady(props.whenReady);
      }
      setMap(instance);
    }
  }, [mapRef, map, props]);
  return map;
}
function MapContainer(_ref) {
  let _a = _ref, {
    children,
    className,
    id,
    placeholder,
    style,
    whenCreated
  } = _a, options = __objRest(_a, [
    "children",
    "className",
    "id",
    "placeholder",
    "style",
    "whenCreated"
  ]);
  const mapRef = (0, import_react11.useRef)(null);
  const map = useMapElement(mapRef, options);
  const createdRef = (0, import_react11.useRef)(false);
  (0, import_react11.useEffect)(() => {
    if (map != null && createdRef.current === false && whenCreated != null) {
      createdRef.current = true;
      whenCreated(map);
    }
  }, [map, whenCreated]);
  (0, import_react11.useEffect)(() => {
    return () => {
      map == null ? void 0 : map.remove();
    };
  }, [map]);
  const [props] = (0, import_react11.useState)({
    className,
    id,
    style
  });
  const context = (0, import_react11.useMemo)(() => map ? {
    __version: CONTEXT_VERSION,
    map
  } : null, [map]);
  const contents = context ? import_react11.default.createElement(LeafletProvider, {
    value: context
  }, children) : placeholder != null ? placeholder : null;
  return import_react11.default.createElement("div", _extends({}, props, {
    ref: mapRef
  }), contents);
}

// node_modules/react-leaflet/esm/Marker.js
var import_leaflet12 = __toESM(require_leaflet_src());
var Marker = createLayerComponent(function createMarker(_ref, ctx) {
  let _a = _ref, {
    position
  } = _a, options = __objRest(_a, [
    "position"
  ]);
  const instance = new import_leaflet12.Marker(position, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updateMarker(marker, props, prevProps) {
  if (props.position !== prevProps.position) {
    marker.setLatLng(props.position);
  }
  if (props.icon != null && props.icon !== prevProps.icon) {
    marker.setIcon(props.icon);
  }
  if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {
    marker.setZIndexOffset(props.zIndexOffset);
  }
  if (props.opacity != null && props.opacity !== prevProps.opacity) {
    marker.setOpacity(props.opacity);
  }
  if (marker.dragging != null && props.draggable !== prevProps.draggable) {
    if (props.draggable === true) {
      marker.dragging.enable();
    } else {
      marker.dragging.disable();
    }
  }
});

// node_modules/react-leaflet/esm/Pane.js
var import_react12 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
var DEFAULT_PANES = ["mapPane", "markerPane", "overlayPane", "popupPane", "shadowPane", "tilePane", "tooltipPane"];
function omitPane(obj, pane) {
  const _a = obj, {
    [pane]: _p
  } = _a, others = __objRest(_a, [
    __restKey(pane)
  ]);
  return others;
}
function createPane(props, context) {
  var _a;
  const name = props.name;
  if (DEFAULT_PANES.indexOf(name) !== -1) {
    throw new Error(`You must use a unique name for a pane that is not a default Leaflet pane: ${name}`);
  }
  if (context.map.getPane(name) != null) {
    throw new Error(`A pane with this name already exists: ${name}`);
  }
  const parentPaneName = (_a = props.pane) != null ? _a : context.pane;
  const parentPane = parentPaneName ? context.map.getPane(parentPaneName) : void 0;
  const element = context.map.createPane(name, parentPane);
  if (props.className != null) {
    addClassName(element, props.className);
  }
  if (props.style != null) {
    Object.keys(props.style).forEach((key) => {
      element.style[key] = props.style[key];
    });
  }
  return element;
}
function Pane(props) {
  const [paneElement, setPaneElement] = (0, import_react12.useState)();
  const context = useLeafletContext();
  const newContext = (0, import_react12.useMemo)(() => __spreadProps(__spreadValues({}, context), {
    pane: props.name
  }), [context]);
  (0, import_react12.useEffect)(() => {
    setPaneElement(createPane(props, context));
    return function removeCreatedPane() {
      const pane = context.map.getPane(props.name);
      pane == null ? void 0 : pane.remove == null ? void 0 : pane.remove();
      if (context.map._panes != null) {
        context.map._panes = omitPane(context.map._panes, props.name);
        context.map._paneRenderers = omitPane(context.map._paneRenderers, props.name);
      }
    };
  }, []);
  return props.children != null && paneElement != null ? (0, import_react_dom2.createPortal)(import_react12.default.createElement(LeafletProvider, {
    value: newContext
  }, props.children), paneElement) : null;
}

// node_modules/react-leaflet/esm/Polygon.js
var import_leaflet13 = __toESM(require_leaflet_src());
var Polygon = createPathComponent(function createPolygon(_ref, ctx) {
  let _a = _ref, {
    positions
  } = _a, options = __objRest(_a, [
    "positions"
  ]);
  const instance = new import_leaflet13.Polygon(positions, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updatePolygon(layer, props, prevProps) {
  if (props.positions !== prevProps.positions) {
    layer.setLatLngs(props.positions);
  }
});

// node_modules/react-leaflet/esm/Polyline.js
var import_leaflet14 = __toESM(require_leaflet_src());
var Polyline = createPathComponent(function createPolyline(_ref, ctx) {
  let _a = _ref, {
    positions
  } = _a, options = __objRest(_a, [
    "positions"
  ]);
  const instance = new import_leaflet14.Polyline(positions, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updatePolyline(layer, props, prevProps) {
  if (props.positions !== prevProps.positions) {
    layer.setLatLngs(props.positions);
  }
});

// node_modules/react-leaflet/esm/Popup.js
var import_leaflet15 = __toESM(require_leaflet_src());
var import_react13 = __toESM(require_react());
var Popup = createOverlayComponent(function createPopup(props, context) {
  return {
    instance: new import_leaflet15.Popup(props, context.overlayContainer),
    context
  };
}, function usePopupLifecycle(element, context, props, setOpen) {
  const {
    onClose,
    onOpen,
    position
  } = props;
  (0, import_react13.useEffect)(function addPopup() {
    const {
      instance
    } = element;
    function onPopupOpen(event) {
      if (event.popup === instance) {
        instance.update();
        setOpen(true);
        onOpen == null ? void 0 : onOpen();
      }
    }
    function onPopupClose(event) {
      if (event.popup === instance) {
        setOpen(false);
        onClose == null ? void 0 : onClose();
      }
    }
    context.map.on({
      popupopen: onPopupOpen,
      popupclose: onPopupClose
    });
    if (context.overlayContainer == null) {
      if (position != null) {
        instance.setLatLng(position);
      }
      instance.openOn(context.map);
    } else {
      context.overlayContainer.bindPopup(instance);
    }
    return function removePopup() {
      var _context$overlayConta;
      context.map.off({
        popupopen: onPopupOpen,
        popupclose: onPopupClose
      });
      (_context$overlayConta = context.overlayContainer) == null ? void 0 : _context$overlayConta.unbindPopup();
      context.map.removeLayer(instance);
    };
  }, [element, context, setOpen, onClose, onOpen, position]);
});

// node_modules/react-leaflet/esm/Rectangle.js
var import_leaflet16 = __toESM(require_leaflet_src());
var Rectangle = createPathComponent(function createRectangle(_ref, ctx) {
  let _a = _ref, {
    bounds
  } = _a, options = __objRest(_a, [
    "bounds"
  ]);
  const instance = new import_leaflet16.Rectangle(bounds, options);
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updateRectangle(layer, props, prevProps) {
  if (props.bounds !== prevProps.bounds) {
    layer.setBounds(props.bounds);
  }
});

// node_modules/react-leaflet/esm/ScaleControl.js
var import_leaflet17 = __toESM(require_leaflet_src());
var ScaleControl = createControlComponent(function createScaleControl(props) {
  return new import_leaflet17.Control.Scale(props);
});

// node_modules/react-leaflet/esm/SVGOverlay.js
var import_leaflet18 = __toESM(require_leaflet_src());
var import_react14 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var useSVGOverlayElement = createElementHook(function createSVGOverlay(props, context) {
  const _a = props, {
    attributes,
    bounds
  } = _a, options = __objRest(_a, [
    "attributes",
    "bounds"
  ]);
  const container = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  container.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  if (attributes != null) {
    Object.keys(attributes).forEach((name) => {
      container.setAttribute(name, attributes[name]);
    });
  }
  return {
    instance: new import_leaflet18.SVGOverlay(container, bounds, options),
    container,
    context
  };
}, updateMediaOverlay);
var useSVGOverlay = createLayerHook(useSVGOverlayElement);
function SVGOverlayComponent(_ref, ref) {
  let _a = _ref, {
    children
  } = _a, options = __objRest(_a, [
    "children"
  ]);
  const {
    instance,
    container
  } = useSVGOverlay(options).current;
  (0, import_react14.useImperativeHandle)(ref, () => instance);
  return container == null || children == null ? null : (0, import_react_dom3.createPortal)(children, container);
}
var SVGOverlay = (0, import_react14.forwardRef)(SVGOverlayComponent);

// node_modules/react-leaflet/esm/TileLayer.js
var import_leaflet19 = __toESM(require_leaflet_src());
var TileLayer = createTileLayerComponent(function createTileLayer(_ref, context) {
  let _a = _ref, {
    url
  } = _a, options = __objRest(_a, [
    "url"
  ]);
  return {
    instance: new import_leaflet19.TileLayer(url, withPane(options, context)),
    context
  };
}, updateGridLayer);

// node_modules/react-leaflet/esm/Tooltip.js
var import_leaflet20 = __toESM(require_leaflet_src());
var import_react15 = __toESM(require_react());
var Tooltip = createOverlayComponent(function createTooltip(props, context) {
  return {
    instance: new import_leaflet20.Tooltip(props, context.overlayContainer),
    context
  };
}, function useTooltipLifecycle(element, context, props, setOpen) {
  const {
    onClose,
    onOpen,
    position
  } = props;
  (0, import_react15.useEffect)(function addTooltip() {
    const container = context.overlayContainer;
    if (container == null) {
      return;
    }
    const {
      instance
    } = element;
    const onTooltipOpen = (event) => {
      if (event.tooltip === instance) {
        if (position) {
          instance.setLatLng(position);
        }
        instance.update();
        setOpen(true);
        onOpen == null ? void 0 : onOpen();
      }
    };
    const onTooltipClose = (event) => {
      if (event.tooltip === instance) {
        setOpen(false);
        onClose == null ? void 0 : onClose();
      }
    };
    container.on({
      tooltipopen: onTooltipOpen,
      tooltipclose: onTooltipClose
    });
    container.bindTooltip(instance);
    return function removeTooltip() {
      container.off({
        tooltipopen: onTooltipOpen,
        tooltipclose: onTooltipClose
      });
      if (container._map != null) {
        container.unbindTooltip();
      }
    };
  }, [element, context, setOpen, onClose, onOpen, position]);
});

// node_modules/react-leaflet/esm/VideoOverlay.js
var import_leaflet21 = __toESM(require_leaflet_src());
var VideoOverlay = createLayerComponent(function createVideoOverlay(_ref, ctx) {
  let _a = _ref, {
    bounds,
    url
  } = _a, options = __objRest(_a, [
    "bounds",
    "url"
  ]);
  const instance = new import_leaflet21.VideoOverlay(url, bounds, options);
  if (options.play === true) {
    var _instance$getElement;
    (_instance$getElement = instance.getElement()) == null ? void 0 : _instance$getElement.play();
  }
  return {
    instance,
    context: __spreadProps(__spreadValues({}, ctx), {
      overlayContainer: instance
    })
  };
}, function updateVideoOverlay(overlay, props, prevProps) {
  updateMediaOverlay(overlay, props, prevProps);
  if (typeof props.url === "string" && props.url !== prevProps.url) {
    overlay.setUrl(props.url);
  }
  const video = overlay.getElement();
  if (video != null) {
    if (props.play === true && !prevProps.play) {
      video.play();
    } else if (!props.play && prevProps.play === true) {
      video.pause();
    }
  }
});

// node_modules/react-leaflet/esm/WMSTileLayer.js
var import_leaflet22 = __toESM(require_leaflet_src());
var WMSTileLayer = createTileLayerComponent(function createWMSTileLayer(_ref, context) {
  let _a = _ref, {
    params = {},
    url
  } = _a, options = __objRest(_a, [
    "params",
    "url"
  ]);
  return {
    instance: new import_leaflet22.TileLayer.WMS(url, __spreadValues(__spreadValues({}, params), withPane(options, context))),
    context
  };
}, function updateWMSTileLayer(layer, props, prevProps) {
  updateGridLayer(layer, props, prevProps);
  if (props.params != null && props.params !== prevProps.params) {
    layer.setParams(props.params);
  }
});

// node_modules/react-leaflet/esm/ZoomControl.js
var import_leaflet23 = __toESM(require_leaflet_src());
var ZoomControl = createControlComponent(function createZoomControl(props) {
  return new import_leaflet23.Control.Zoom(props);
});
export {
  AttributionControl,
  Circle,
  CircleMarker,
  FeatureGroup,
  GeoJSON,
  ImageOverlay,
  LayerGroup,
  LayersControl,
  MapConsumer,
  MapContainer,
  Marker,
  Pane,
  Polygon,
  Polyline,
  Popup,
  Rectangle,
  SVGOverlay,
  ScaleControl,
  TileLayer,
  Tooltip,
  VideoOverlay,
  WMSTileLayer,
  ZoomControl,
  useMap,
  useMapEvent,
  useMapEvents
};
//# sourceMappingURL=react-leaflet.js.map
